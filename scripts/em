#!/usr/bin/env bash

# A simple script to open a given file in emacs,
# and detatch the process from the parent terminal 

source $( type -p bash-std )




function options
{
    cat <<EOF
--buffalo,-b; look for file (if any given) on buffalo, via george
--enzo,-e; look for file (if any given) on enzo, via george
--george,-g; look for file (if any given) on george
--terminal,-t; open file in the terminal, don't detach process from parent shell 
EOF
}

bash-std-application-init "$@" < <( options ) || die "failed"




function get_last_arg
{
    local args=( $@ )
    local num_args=${#args[@]}
    echo ${args[$(( num_args - 1 ))]}
}


function sanitize_inputs
{
    if (( options_george + options_buffalo + options_enzo > 1 )); then
        die "--george, --enzo and --buffalo are mutually exclusive"
    fi
}


function get_filename
{
    local last_arg=$( get_last_arg $@ )
    local file=""
    if [[ -z "$( grep '^-' <<< $last_arg )" ]]; then file="$last_arg"; fi
    if (( options_george )); then
        file="/ssh:$( where-is-george ):$file"
    elif (( options_buffalo )); then
        file="/ssh:$( where-is-george )\|ssh:buffalo:$file"
    elif (( options_enzo )); then
        file="/ssh:$( where-is-george )\|ssh:enzo:$file"
    fi
    echo $file
}





sanitize_inputs $@  # todo: see if this still breaks when given 2 files with "$@" instead of $@

file="$( get_filename $@ )"
command="emacsclient -a '' -c $file"
if (( options_terminal )); then
    command+=" -nw"
else
    command+=" &!"
fi
eval "$command"
