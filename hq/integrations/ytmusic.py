#!/usr/bin/env python3


from pathlib import Path

from ytmusicapi import YTMusic, OAuthCredentials, setup

from hq.sysbs import find_hq
from hq.io import load_dict, save_dict
from hq.datetime import dense_iso_timestamp


# OAuth authentication (more robust but more fiddly)
DEFAULT_OAUTH_PATH = find_hq() / "etc/ytmusic/oauth.json"
DEFAULT_CLIENT_INFO_PATH = find_hq() / "etc/ytmusic/client_info.json"
OAUTH_DOCS_URL = "https://ytmusicapi.readthedocs.io/en/stable/setup/oauth.html"
OAUTH_NOT_FOUND_TEMPLATE = """
OAuth credentials file not found: {oauth_path}

This file can be generated using the `ytmusicapi oauth` command, see: {oauth_docs_url}
"""
CLIENT_INFO_NOT_FOUND_TEMPLATE = """
Client info file not found: {client_info_path}

Expected to read keys "client_id" and "client_secret" from this file.

These can be generated from the Google Cloud Console, see: {oauth_docs_url}
"""

# Browser authentication (hackier but easier)
DEFAULT_BROWSER_JSON_PATH = find_hq() / "etc/ytmusic/browser.json"
DEFAULT_HEADERS_RAW_PATH = find_hq() / "etc/ytmusic/headers_raw"
DEFAULT_CACHE_DIR = find_hq() / "etc/ytmusic/cache"


NUM_PLAYLISTS_QUERY_LIMIT = 100
LIKES_QUERY_LIMIT = 2000
LIKES_PLAYLIST_NAME = "Liked Music"


def authenticate_oauth(
    oauth_path: Path = DEFAULT_OAUTH_PATH,
    client_info_path: Path = DEFAULT_CLIENT_INFO_PATH,
) -> YTMusic:
    """
    Authenticate with YouTube Music (required to access the API)

    See https://ytmusicapi.readthedocs.io/en/stable/setup/oauth.html

    Args:
        oauth_path: Path to the OAuth credentials file, as generated by the
            `ytmusicapi oauth` command
        client_info_path: Path to the client info file, which is expected to contain the
            keys "client_id" and "client_secret" with their respective values

    Returns:
        Authenticated YTMusic object
    """
    # Ensure both input files exist
    if not client_info_path.exists():
        raise FileNotFoundError(
            CLIENT_INFO_NOT_FOUND_TEMPLATE.format(
                client_info_path=client_info_path, oauth_docs_url=OAUTH_DOCS_URL
            )
        )
    if not oauth_path.exists():
        raise FileNotFoundError(
            OAUTH_NOT_FOUND_TEMPLATE.format(
                oauth_path=oauth_path, oauth_docs_url=OAUTH_DOCS_URL
            )
        )

    # Load the client info from file
    client_info = load_dict(client_info_path)
    oauth_credentials = OAuthCredentials(
        client_id=client_info["client_id"],
        client_secret=client_info["client_secret"],
    )

    # Authenticate with YouTube Music and return the authenticated object
    return YTMusic(str(oauth_path), oauth_credentials=oauth_credentials)


def authenticate_browser(
    browser_json_path: Path = DEFAULT_BROWSER_JSON_PATH,
) -> YTMusic:
    """
    Authenticate with YouTube Music using a browser-generated JSON file

    Args:
        browser_json_path: Path to the JSON file generated by the `ytmusicapi browser`
            command

    Returns:
        Authenticated YTMusic object
    """
    return YTMusic(str(browser_json_path))


def get_playlist(
    ytmusic: YTMusic,
    playlist_name: str = LIKES_PLAYLIST_NAME,
    cache_dir: Path | None = DEFAULT_CACHE_DIR,
) -> list[dict]:
    """
    Get all liked songs

    Args:
        ytmusic: Authenticated YTMusic object

    Returns:
        List of dictionaries representing liked songs
    """
    # Query for all playlists to find how big they all are
    playlists_metadata = ytmusic.get_library_playlists(limit=NUM_PLAYLISTS_QUERY_LIMIT)

    # Find the playlist with the given name and pull out its song count
    try:
        this_playlist_metadata = next(
            p for p in playlists_metadata if p["title"] == playlist_name
        )
    except StopIteration:
        raise ValueError(
            f"Could not find {playlist_name} among playlists: {playlists_metadata}"
        )
    limit = this_playlist_metadata.get("count", LIKES_QUERY_LIMIT)
    breakpoint()

    # Query for the entire playlist
    playlist = ytmusic.get_playlist(
        playlistId=this_playlist_metadata["playlistId"], limit=limit
    )

    # Save the likes to a cache file if a cache dir was provided
    if cache_dir:
        save_dict(
            {"playlist": playlist},
            cache_dir / f"{playlist_name}.{dense_iso_timestamp()}.json",
        )

    return playlist


# playlists = ytmusic.get_library_playlists()

# things = next(p for p in playlists if p["title"] == "Things")

# things = ytmusic.get_playlist(things["playlistId"], limit=1000)

# tracks_by_chubb = [
#     track
#     for track in things["tracks"]
#     if any("Chubb" in artist["name"] for artist in track["artists"])
# ]

# print(tracks_by_chubb)
